## Longest Mountain in Array Problem
### Overview
Given an array of n distinct elements, find the minimum number of swaps required to sort the array.
<hr>

### Solution
We would solve this problem with the following steps 

- We will try to find its peak i.e the point where the array will be of form {a[i] > a[i-1]} and {a[i] < a[i+1]} .
- Then after finding the point we will traverse the array in forward direction until a[i] is smaller then a[i+1] .
- Also we will traverse in the backward direction until the a[j] greater than a[j-1] .
- We will store the Max Length traversed in temp variable by doing temp = i - j .
- We will compare the temp value with Max value and store the Maximum length in Max Variable.

![hint_valid_mountain_array](https://user-images.githubusercontent.com/63805002/136500596-a33e4f91-f2ee-4a2f-8f8f-12743fa7f249.png)
<hr>

### Code 
```
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

int countMinSwaps(vector<int> arr){
    int ans = 0;
    int n = arr.size();
    //know the acutal positions of elements (sorting)
    //store the current indices
    pair<int,int> ap[n];
    for(int i = 0; i < n; ++i){
        ap[i].first = arr[i];
        ap[i].second = i;
    }

    //Sorting
    sort(ap,ap+n);

    //build the main logic
    vector<bool> visited(n,false);

    for(int i = 0; i < n; ++i){
        //if element is visited or element is in right position
        int old_position = ap[i].second;
        
        if(visited[i] == true or old_position == i)
            continue;

        //visiting the element (index) for first time
        int node = i;
        int cycle = 0;
        while(visited[node] == false){
            visited[node] = true;
            int next_node = ap[node].second;
            node = next_node;
            cycle += 1;
        }

        ans += (cycle - 1);
    } 

    return ans;
}


int main(){
    vector<int> arr{1,5,3,2,4};
    cout<<countMinSwaps(arr)<<endl;
    return 0;
}
```
<hr>

### Input and Output Analysis
```
Given array is 
5,6,1,2,3,4,5,4,3,2,0,1,2,3,-2,4

Output : 9

Explanation: The largest mountain is [1,2,3,4,5,4,3,2,0] which has length 9 Having peak 5 with ends at 1 and 0. 
```

### Complexity analysis

**Auxiliary Space** : O(1) <br/>
**Time Complexity** : O(n)

## Example 1.
```
Input: arr = [2,1,4,7,3,2,5]
Output: 5
Explanation: The largest mountain is [1,4,7,3,2] which has length 5.
```
## Example 2.
```
Input: arr = [2,2,2]
Output: 0
Explanation: There is no mountain.
```
## Contraints Followed/Passed

- 1 <= arr.length <= 10^4
- 0 <= arr[i] <= 10^4
- solved it using only one pass
- solved it in O(1) space

## Author

* [@ksheetiz](https://github.com/ksheetiz)

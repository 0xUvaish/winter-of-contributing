## Doubly Linked List

Doubly linked list is a complex type of linked list in which a node contains a pointer to the previous as well as the next node in the sequence. Therefore, in a doubly linked list, a node consists of three parts: node data, pointer to the next node in sequence (next pointer) , pointer to the previous node (previous pointer). A sample node in a doubly linked list is shown in the figure.

<p align = "center">
  <img src = "https://static.javatpoint.com/ds/images/doubly-linked-list.png">
</p>

Following are the important terms to understand the concept of doubly linked list:-

* **Link:-** Each link of a linked list can store a data called an element.

* **Next:-** Each link of a linked list contains a link to the next link called Next.

* **Prev:-** Each link of a linked list contains a link to the previous link called Prev.

* **LinkedList:-** A Linked List contains the connection link to the first link called First and to the last link called Last.

## Doubly Linked List Representation

<p align = "center">
  <img src = "https://www.tutorialspoint.com/data_structures_algorithms/images/doubly_linked_list.jpg">
</p>

As per the above illustration, following are the important points to be considered.

* Doubly Linked List contains a link element called first and last.

* Each link carries a data field(s) and two link fields called next and prev.

* Each link is linked with its next link using its next link.

* Each link is linked with its previous link using its previous link.

* The last link carries a link as null to mark the end of the list.


In a singly linked list, we could traverse only in one direction, because each node contains address of the next node and it doesn't have any record of its previous nodes. However, doubly linked list overcome this limitation of singly linked list. Due to the fact that, each node of the list contains the address of its previous node, we can find all the details about the previous node as well by using the previous address stored inside the previous part of each node.

## Memory Representation of a doubly linked list

Memory Representation of a doubly linked list is shown in the following image. Generally, doubly linked list consumes more space for every node and therefore, causes more expansive basic operations such as insertion and deletion. However, we can easily manipulate the elements of the list since the list maintains pointers in both the directions (forward and backward).

In the following image, the first element of the list that is i.e. 13 stored at address 1. The head pointer points to the starting address 1. Since this is the first element being added to the list therefore the prev of the list contains null. The next node of the list resides at address 4 therefore the first node contains 4 in its next pointer.

We can traverse the list in this way until we find any node containing null or -1 in its next part.

<p align = "center">
  <img src = "https://static.javatpoint.com/ds/images/doubly-linked-list-memory-representation.png">
</p>

## Implementation

```cpp
#include <iostream>
using namespace std;

// node creation
struct Node {
  int data;
  struct Node* next;
  struct Node* prev;
};

// insert node at the front
void insertFront(struct Node** head, int data) {
  // allocate memory for newNode
  struct Node* newNode = new Node;

  // assign data to newNode
  newNode->data = data;

  // make newNode as a head
  newNode->next = (*head);

  // assign null to prev
  newNode->prev = NULL;

  // previous of head (now head is the second node) is newNode
  if ((*head) != NULL)
    (*head)->prev = newNode;

  // head points to newNode
  (*head) = newNode;
}

// insert a node after a specific node
void insertAfter(struct Node* prev_node, int data) {
  // check if previous node is null
  if (prev_node == NULL) {
    cout << "previous node cannot be null";
    return;
  }

  // allocate memory for newNode
  struct Node* newNode = new Node;

  // assign data to newNode
  newNode->data = data;

  // set next of newNode to next of prev node
  newNode->next = prev_node->next;

  // set next of prev node to newNode
  prev_node->next = newNode;

  // set prev of newNode to the previous node
  newNode->prev = prev_node;

  // set prev of newNode's next to newNode
  if (newNode->next != NULL)
    newNode->next->prev = newNode;
}

// insert a newNode at the end of the list
void insertEnd(struct Node** head, int data) {
  // allocate memory for node
  struct Node* newNode = new Node;

  // assign data to newNode
  newNode->data = data;

  // assign null to next of newNode
  newNode->next = NULL;

  // store the head node temporarily (for later use)
  struct Node* temp = *head;

  // if the linked list is empty, make the newNode as head node
  if (*head == NULL) {
    newNode->prev = NULL;
    *head = newNode;
    return;
  }

  // if the linked list is not empty, traverse to the end of the linked list
  while (temp->next != NULL)
    temp = temp->next;

  // now, the last node of the linked list is temp

  // assign next of the last node (temp) to newNode
  temp->next = newNode;

  // assign prev of newNode to temp
  newNode->prev = temp;
}

// delete a node from the doubly linked list
void deleteNode(struct Node** head, struct Node* del_node) {
  // if head or del is null, deletion is not possible
  if (*head == NULL || del_node == NULL)
    return;

  // if del_node is the head node, point the head pointer to the next of del_node
  if (*head == del_node)
    *head = del_node->next;

  // if del_node is not at the last node, point the prev of node next to del_node to the previous of del_node
  if (del_node->next != NULL)
    del_node->next->prev = del_node->prev;

  // if del_node is not the first node, point the next of the previous node to the next node of del_node
  if (del_node->prev != NULL)
    del_node->prev->next = del_node->next;

  // free the memory of del_node
  free(del_node);
}

// print the doubly linked list
void displayList(struct Node* node) {
  struct Node* last;

  while (node != NULL) {
    cout << node->data << "->";
    last = node;
    node = node->next;
  }
  if (node == NULL)
    cout << "NULL\n";
}

int main() {
  // initialize an empty node
  struct Node* head = NULL;

  insertEnd(&head, 5);
  insertFront(&head, 1);
  insertFront(&head, 6);
  insertEnd(&head, 9);

  // insert 11 after head
  insertAfter(head, 11);

  // insert 15 after the seond node
  insertAfter(head->next, 15);

  displayList(head);

  // delete the last node
  deleteNode(&head, head->next->next->next->next->next);

  displayList(head);
}
```

## Output

```
 6->11->15->1->5->9->NULL
 6->11->15->1->5->NULL
```

## Doubly Linked List Complexity

Doubly Linked List Complexity | Time Complexity | Space Complexity
----------------------------- | --------------- | ----------------
**Insertion Operation**       |   O(1) or O(n)  |      O(1)
**Deletion Operation**        |      O(1)       |      O(1)

   **1. Complexity of Insertion Operation**

   * The insertion operations that do not require traversal have the time complexity of `O(1)`

   * And, insertion that requires traversal has time complexity of `O(n)`.

   * The space complexity is `O(1)`.

   **2. Complexity of Deletion Operation**

   * All deletion operations run with time complexity of `O(1)`.

   * And, the space complexity is `O(1)`.



## Doubly Linked List Applications

* Redo and undo functionality in software.

* Forward and backward navigation in browsers.

* For navigation systems where forward and backward navigation is required.


REFERENCES:-

* [Javatpoint](https://www.javatpoint.com/doubly-linked-list)
* [Tutorialspoint](https://www.tutorialspoint.com/data_structures_algorithms/doubly_linked_list_algorithm.htm)
* [Programiz](https://www.programiz.com/dsa/doubly-linked-list)
